<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Guessing Game (WIP) - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="../introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="../getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="../language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language-basics/guessing-game.html" class="active"><strong aria-hidden="true">3.1.</strong> Guessing Game (WIP)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Primitives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Documentation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Tests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Clippy and Fmt</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.7.</strong> Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> Complex Structures</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Conversions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Pattern Matching</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Memory</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.18.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.19.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.20.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap and StructOpt</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="guessing-game"><a class="header" href="#guessing-game">Guessing Game</a></h1>
<p>We‚Äôre going to start in the same place as the official Rust book,
<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html" title="" target="_blank">with a guessing game</a>! However, we‚Äôre going to
do things a little bit differently.</p>
<p>We‚Äôll start as we did with Hello World, and create a new project with cargo</p>
<pre><code class="language-shell">$ cargo new guessing-game
</code></pre>
<p>Opening <code>src/main.rs</code> we#ll see the same code as before:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>As we step through this tutorial, if you mouse over the code examples, you can see some buttons that will let you</p>
<ol>
<li>‚éò Copy the example to your clipboard</li>
<li>‚èµ Run the example via <a href="https://play.rust-lang.org" title="" target="_blank">rust playground</a> (where possible)</li>
<li>üëÅ Show any code I‚Äôve opted to hide for clarity, try this on the next block</li>
</ol>
<p>Lets quickly change our hello world message to something that welcomes us to the game.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    println!(&quot;Welcome to the guessing game!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>And a quick description:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Welcome to the guessing game!&quot;);
</span>    println!(&quot;I have chosen a number between 1 and 100, can you guess it?&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Lets pick a number that the user has to guess, something between 1 and 100 would be nice, and I‚Äôm going to stick this
at the top of the function (don‚Äôt forget you can click the üëÅ on the example to see)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let actual = 53;
<span class="boring">    println!(&quot;Welcome to the guessing game!&quot;);
</span><span class="boring">    println!(&quot;I have chosen a number between 1 and 100, can you guess it?&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>In Rust, variables have a ‚Äútype‚Äù, that is to say, they have certain behaviors and representations depending on the type.
By default, a number is represented as an <code>i32</code>, that is a 32 bit signed integer. This means that it can represent a 
number between <code>-2,147,483,648</code> and <code>2,147,483,647</code>.</p>
<p>There are many other ways to represent numbers, from big to small, positive only or allowing negative numbers, allowing
decimal places or exactly sized to system memory. We‚Äôll talk more about how to specify the type and how to decide the
right number type for you next time, but for now an <code>i32</code> is just fine.</p>
<p>Lets output the number (even though we haven‚Äôt asked for a guess yet)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let actual = 53;
</span><span class="boring">    println!(&quot;Welcome to the guessing game!&quot;);
</span><span class="boring">    println!(&quot;I have chosen a number between 1 and 100, can you guess it?&quot;);
</span>    println!(&quot;The number I chose was {actual}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Great‚Ä¶ not much of a game is it.</p>
<p>In order to get some user input, we need to read from the terminal. Before we tell the user what the actual number was
lets ask them to guess</p>
<pre><code class="language-rust noplayground"><span class="boring">fn main() {
</span><span class="boring">    let actual = 53;
</span><span class="boring">    println!(&quot;Welcome to the guessing game!&quot;);
</span><span class="boring">    println!(&quot;I have chosen a number between 1 and 100, can you guess it?&quot;);
</span><span class="boring">   
</span>    println!(&quot;Enter a number between 1 and 100&quot;);
<span class="boring">   
</span><span class="boring">    println!(&quot;The number I chose was {actual}&quot;);
</span><span class="boring">}</span></code></pre>
<p>We‚Äôre then going to read a line of input from the user. When the program runs in the terminal, we can ask the user to
type things, regardless of whether you are on Windows, Mac or Linux, this input is passed into the program through a
stream of data called <code>stdin</code> (standard in).</p>
<p>Rust comes with a ‚Äústandard library‚Äù that we can access through <code>std</code>. I always say S T D, but you may also here people
call it ‚Äústud‚Äù. Inside of this is a module (a grouping) called io that deals with input and output. If we weren‚Äôt using
the <code>println!</code> macro, this is where we‚Äôd have to come to write things out to the terminal too, via a stream called 
<code>stdout</code> (standard out). </p>
<blockquote>
<p>For completions sake I should mention there is one more stream called <code>stderr</code> (standard error). This is also an
output stream that we can use to separate ‚Äúgood‚Äù output that is relevant to the normal use of the program to really 
any other kind of output, whether that be errors or just information not directly relevant to the main output.</p>
<p>For example, on Mac and Linux, if you use <code>cargo run 2&gt; /dev/null</code> to run your program, you‚Äôll see that you lose the
messages about your program being compiled because we redirected stderr (stream 2) to the void of <code>/dev/null</code>, and
Cargo sensibly decided that <em>it‚Äôs</em> output is not relevant to your programs normal output</p>
<p>On Windows the same can be achieved in cmd using <code>cargo run 2&gt; nul</code> (note, only one l in nul), or in powershell with
<code>cargo run 2&gt; $null</code> (two l‚Äôs this time and a dollar, no idea why its different)</p>
<p>There are more streams, denoted by numbers, but these are rarely used and are way outside of the scope of this series.</p>
<p><code>stderr</code> is really useful for things like logging and we‚Äôll talk more about streams in the future.</p>
</blockquote>
<p>So, we get stdin using <code>std::io::stdin()</code>, this is a function call that returns a temporary handle to the input stream.</p>
<p>The double colons just tell Rust that you‚Äôre looking for something inside a module (that grouping I mentioned). We‚Äôll 
cover modules in detail later, including how, why and when to make your own, as well as better ways to access them, but
since we only need to write this line once, this is fine.</p>
<p>Off the back of this, we can call <code>.lines()</code> which is a method (a special type of function that belongs specifically to
some other thing, in this case the handle to that data). Below I put this on a new line for legibility, but you don‚Äôt
need to do this.</p>
<p><code>.lines()</code> returns an iterator, something we can step through a bit at a time. In this case, if the input was multiple
lines then the iterator would return one line at a time. We get the next line by calling <code>.next()</code> on the iterator.</p>
<p>If we add this all in our code looks like this</p>
<pre><code class="language-rust noplayground"><span class="boring">fn main() {
</span><span class="boring">    let actual = 53;
</span><span class="boring">    println!(&quot;Welcome to the guessing game!&quot;);
</span><span class="boring">    println!(&quot;I have chosen a number between 1 and 100, can you guess it?&quot;);
</span><span class="boring">   
</span><span class="boring">    println!(&quot;Enter a number between 1 and 100&quot;);
</span>    let input = std::io::stdin()
            .lines()
            .next()
            .expect(&quot;No input read&quot;)
            .expect(&quot;Could not get input from stdin&quot;);
    println!(&quot;Your guess was {input}&quot;);
<span class="boring">   
</span><span class="boring">    println!(&quot;The number I chose was {actual}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Wait wait wait, what are those <code>expect</code>s about?!</p>
<p>In software, functions can sometimes return something or nothing, and sometimes they could work or not work. These two
expects handle one case of each.</p>
<p>The first expect then:</p>
<pre><code class="language-rust ignore">.expect(&quot;No input read&quot;)</code></pre>
<p>When we call <code>.next()</code> on any iterator, there either is something next or there isn‚Äôt. In some languages this
might return either the data you expect, or a <code>null</code> value. This means you must either manually check the thing returned
was null, or don‚Äôt check, and risk your program breaking at some other point when it expected that data but got null
instead. Obviously many people think this ambiguity is bad, including Tony Hoare, arguably the ‚Äúinventor‚Äù of this kind
of behavior, who has called it his ‚Äúbillion-dollar mistake‚Äù.</p>
<p>Rust does not allow you to use types like this interchangeably, the type can not be something or nothing, it must be
something that represents the concept of something or nothing, in this case a type called <code>Option</code>. Importantly the
<code>Option</code> itself is not the data you were expecting, so you are forced to check whether it contains that data before you
can use it. </p>
<p>The idiomatic way to do this depends on whether your code can recover from the data not being there. In our case we‚Äôre
going to just say we can‚Äôt deal with it not being there, we don‚Äôt want to continue running the program and we want the
program to stop. We use <code>.expect(&quot;message&quot;)</code> to say, if this is nothing, we are giving up, stop the program and print
our message (plus a few other useful bits) to the <code>stderr</code> (see above).</p>
<p>This still isn‚Äôt very idiomatic, ideally we‚Äôd convert the bad behavior into a proper error and handle it more sensibly
but for now its passable. Maybe‚Ä¶ we‚Äôll fix this later. :)</p>
<p>Speaking of proper errors:</p>
<pre><code class="language-rust ignore">.expect(&quot;Could not get input from stdin&quot;);</code></pre>
<p>If the Option we got from <code>.next()</code> contains something instead of nothing, it <em>still</em> doesn‚Äôt actually the users input.
It turns out that reading data from <code>stdin</code> is itself fallible.</p>
<p>Fallibility in programming is another thing we‚Äôve traditionally handled very badly. A common way to deal with this in
other languages is to stop executing and ‚Äúthrow‚Äù an error. The big problem with this is function you are calling does
not explicitly tell you that its fallible (may fail). Worse, it may be that the person who wrote that function didn‚Äôt
even know because the fallibility is deeply nested.</p>
<p>Rust does away with this with another type called <code>Result</code>. If your function can fail, it must return a Result type.
Like with <code>Option</code>, <code>Result</code> is its own type that contains either the data we wanted, or an error.</p>
<p>Again, the idiomatic way to handle this depends on what you‚Äôre trying to do, is the error recoverable, and how do we
want to report the error back to the user. Using <code>expect</code> will, again, cause the program to immediately stop with the
error message and other bits sent to <code>stderr</code>.</p>
<p>But anyway, we now have a working program, there is an actual number, the user guesses a number, we print both to the
screen.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going Further</a></h2>
<p>The input data we get from the user is a string, not a number so, if I enter a string, it just prints that as my guess.</p>
<pre><code class="language-text">Welcome to the guessing game!
I have chosen a number between 1 and 100, can you guess it?
Enter a number between 1 and 100
obvious nonsense
Your guess was obvious nonsense
The number I chose was 53
</code></pre>
<p>Because <code>actual</code> is an ‚Äúi32‚Äù and <code>input</code> is a ‚ÄúString‚Äù, we can‚Äôt simply compare them, we need to convert one type into
the other. We can do this with a method on strings called <code>.parse()</code>. As you can probably guess <code>parse</code> is fallible and
if we give it <code>&quot;obvious nonsense&quot;</code> it will error. We can deal with that with another <code>expect</code>.</p>
<p>There‚Äôs something else we need to do though, there are lots of things we could parse our string into, so we need to tell
Rust what we want. There‚Äôs a couple of ways to do this, but the most idiomatic way, and what we‚Äôll do here, is just tell
Rust what the type of the variable is going to be, then Rust is smart enough to <code>parse</code> our String into that data.</p>
<p>Eg:</p>
<pre><code class="language-rust ignore">let guess: i32 = input.parse().expect(&quot;input was not a number&quot;);</code></pre>
<p>That‚Äôs pretty clean, right?</p>
<p>Now that the types are the same, we can do different things depending on whether the the numbers are a match. We can
do this with an <code>if</code> statement. You use an <code>if</code> by giving it something that will evaluate to either true or false. For
example <code>guess == actual</code> will be true if guess is exactly equal to actual, otherwise it will be false. We can follow
the <code>if</code> part immediately with an <code>else</code> that says what to do if the evaluation came to false.</p>
<p>Below is the full function using this if/else:</p>
<pre><code class="language-rust noplayground">fn main() {
    let actual = 53;

    println!(&quot;Welcome to the guessing game!&quot;);
    println!(&quot;I have chosen a number between 1 and 100, can you guess it?&quot;);

    println!(&quot;Enter a number between 1 and 100&quot;);
    let input = std::io::stdin()
        .lines()
        .next()
        .expect(&quot;No input read&quot;)
        .expect(&quot;Could not get input from stdin&quot;);

    let guess: i32 = input.parse().expect(&quot;input was not a number&quot;);

    if guess == actual {
        println!(&quot;Correct!&quot;)
    } else {
        println!(&quot;That was not correct, try again&quot;)
    }
}</code></pre>
<p>Ok, not bad. This is a bit more game like. I‚Äôm not happy about that last expect though. Its quite likely that the user
will enter something thats not a number, even if its just to ‚Äútry it out‚Äù. If you try it in your program, you‚Äôll see
rather a lot of unnecessary output:</p>
<pre><code class="language-text">Welcome to the guessing game!
I have chosen a number between 1 and 100, can you guess it?
Enter a number between 1 and 100
obvious nonsense
thread 'main' panicked at src\main.rs:44:36:
input was not a number: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
