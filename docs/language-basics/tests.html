<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tests (wip) - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="../introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="../getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="../language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language-basics/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="../language-basics/data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../language-basics/control-flow.html"><strong aria-hidden="true">3.3.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../language-basics/functions.html"><strong aria-hidden="true">3.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../language-basics/tests.html" class="active"><strong aria-hidden="true">3.5.</strong> Tests (wip)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Documentation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.7.</strong> Clippy and Fmt</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> Conversions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Pattern Matching</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tests-wip"><a class="header" href="#tests-wip">Tests (WIP)</a></h1>
<p>Tests. Are. Awesome.</p>
<p>They are my favourite bit of software engineering. I‚Äôm sure many of you can relate, but I don‚Äôt tend to trust humans
telling me I‚Äôm doing well at my job. When I make a test pass though, oh that dopamine hits good.</p>
<p>A good test makes sure that the thing we‚Äôre building does what we think it does.</p>
<p>Anecdotally I recently interviewed at a company where I professed my love of tests, and they told me flatly they don‚Äôt
write tests, they ‚Äúmove fast‚Äù. Later in the interview they admitted they were having morale issues because their
engineers were constantly getting called out of hours to fix things.</p>
<p>So, it begs the question: are you moving fast if you‚Äôre writing software that doesn‚Äôt work?</p>
<p>Software engineers are not paid to write software, we‚Äôre paid to solve problems. Tests are what make sure we solved the
problem and by automating our tests they make sure we don‚Äôt accidentally ‚Äúunsolve‚Äù it further down the line.</p>
<h2 id="the-testing-pyramid"><a class="header" href="#the-testing-pyramid">The testing Pyramid</a></h2>
<p>There are many ways to test software, these largely fall into three categories that make up what we call the testing
pyramid.</p>
<div class="pyramid">
<style scoped>
.pyramid code {
    text-align: center;
}
</style>
<pre><code class="language-text">            ‚Üë         /----------\        |           
            |        / End-to-End \       |           
  more      |       /--------------\      |    less   
expensive   |      /   Integration  \     |  expensive
   use      |     /------------------\    |    use    
  less      |    /        Unit        \   |    more   
            |   /----------------------\  ‚Üì           
</code></pre>
</div>
<p>It‚Äôs a pyramid to indicate that, although all tests are important, those lower down the pyramid should be laying the
foundation for the others. Not only should you have more of them, but they will provide the greatest feeling of safety
and security.</p>
<h3 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-End Tests</a></h3>
<p>E2E tests are designed to make sure that the user of the software you‚Äôve created can complete full user
journeys, for example, can the user open, edit and save a file in a desktop application or can a user add an item to
a shopping cart and checkout of an ecommerce store. End-to-End tests are the slowest form of test and lack depth.</p>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Integration tests check that the code you control works correctly with code that your program depends on that you
don‚Äôt control. This would include things like databases or other data stores, web apis, library apis, etc. Integration
tests are also used if your software produces a public API. You write tests to check that people using your software in
its more natural state. Because of the communication component to these tests, these tests are also quite slow.</p>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Unit tests test a single unit of functionality. These tests are the simplest, fastest and should make up the bulk
of your testing. These tests are so important, that it is best practice to write them before you write the code
you‚Äôre going to test.</p>
<p>For this book, we‚Äôre only going to cover Unit Tests. That isn‚Äôt to say that Integration Tests and End-to-End Tests
aren‚Äôt important, they absolutely are, and there are many good guides out there. But, it is to say, that Unit Tests are
<em>so</em> important, that they significantly impact how we communicate about Rust code and particularly libraries that we
might use, and they‚Äôll change the way we talk about Rust in this book going forward.</p>
<h2 id="introduction-to-modules"><a class="header" href="#introduction-to-modules">Introduction to Modules</a></h2>
<p>Unlike many languages, in Rust, tests live with the code that they‚Äôre testing. To explain this we need to talk about
how code in Rust is organised with Modules.</p>
<p>A Module is simply a container for other things, functions, type definitions, other modules, etc. You could think of it
like a physical container, though you can nest any number of containers together. The contents of the module are private
to that module unless explicitly marked as public with the <code>pub</code> keyword.</p>
<p>We define a module with the <code>mod</code> keyword and a name. There are then three ways to define what‚Äôs inside that module:</p>
<ol>
<li>With a directory named the same thing as the module which contains the file <code>mod.rs</code>, eg <code>my_module/mod.rs</code></li>
<li>With a file in the same directory named the same thing as the module, eg <code>my_module.rs</code></li>
<li>Inside curly brackets, eg <code>mod my_module { ... }</code></li>
</ol>
<p>If the module exposes anything publicly, you can then reference them with the path to the module and the name of the
thing you‚Äôre referencing separate by double colons. Sound familiar? It should, this is how we‚Äôve been accessing Rust‚Äôs
standard library. For example, the <code>stdin</code> function is inside the <code>io</code> module, which itself is available inside the
<code>std</code> library.</p>
<p>We access that function using <code>std::io::stdin()</code>. We can also use the <code>use</code> keyword to simplify this a bit, for example:</p>
<pre><code class="language-rust noplayground">use std::io::stdin; // Full name here

fn main() {
    let _ = stdin; // No need to use the full name here
}</code></pre>
<p>We won‚Äôt need this for testing though.</p>
<h2 id="test-modules"><a class="header" href="#test-modules">Test Modules</a></h2>
<p>In Rust, we typically create a test module near the code that is being tested. Let‚Äôs say we want to write a test some of
the functions we wrote in the last chapter (I‚Äôve renamed them slightly below).</p>
<p>First we start by creating a module to test these functions in the same file as the functions exist</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}

fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    // ...
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span>}

mod tests {
    // empty for now
}</code></pre>
<p>As long as nothing in the <code>tests</code> module is used in your main program it shouldn‚Äôt appear in your final binary, however,
this isn‚Äôt good enough. There‚Äôs a risk we might make a mistake, but ever without that, the module will still be
processed by the compiler in order to do things like type checking. We only care about this module when we‚Äôre running
our tests and Rust provides us a way to tell it that, the
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html" title="" target="_blank">
<code>#[cfg(...)]</code> attribute</a>.</p>
<p>Attributes are one of Rusts many meta programming tools which we‚Äôll cover more in the future at increasing difficulty
levels. For now, the <code>cfg</code> attribute allows us to tell the Rust Compiler (<code>rustc</code>) <em>when</em> we want to compile something.
There are many, many ways to use conditional compilation, but for tests its pretty simple, we only want the module
compiled when we‚Äôre building tests and <code>cfg</code> has a ‚Äúpredicate‚Äù to identify this simply called <code>test</code>.</p>
<p>We use <code>cfg</code> to only build our tests module when we‚Äôre building for tests like this:</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
</span><span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
</span><span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    // still empty
}</code></pre>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Now we‚Äôre ready to write our first test.</p>
<p>A test is simply a function that we mark with another attribute <code>#[test]</code>.</p>
<p>Let‚Äôs quickly write a broken test to make sure things are working.</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    
    #[test]
    fn test_split_at() {
        assert!(false, "Intentionally failing a test to show how they work")
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d62bd5aa150a9f0bdab23a98b655fc78" title="" target="_blank">Link to tests</a></p>
<blockquote>
<p>Note: currently mdbook, the tool we‚Äôre using to create the IRISS book, does not support running tests natively.
Instead, we‚Äôll provide a permalink to the relevant code in Rust Playground. Inside Rust Playground, click the three
dots next to Run, and choose Test</p>
</blockquote>
<p>The <code>assert!()</code> macro takes either one or two parameters. The first parameter which is not optional is a boolean value,
or something that evaluates to a boolean. If this boolean is false, then the assertion will cause a panic, and the test
will fail (unless it‚Äôs expected to panic, more on that later).</p>
<p>The second, optional parameter allows us to annotate the assertion, which can help us more easily determine which (if
any) assertion failed in a test that might have multiple assertions. You‚Äôll find that people don‚Äôt use this as much, I‚Äôm
guilty of this too, but I do recommend making an effort to describe each specific assertion. The people you work with,
as well as future you, will appreciate the effort.</p>
<p>There are three main assert macros:</p>
<ul>
<li><code>assert!(&lt;boolean value&gt;, &lt;optional message&gt;)</code> asserts value is true or panics with optional message</li>
<li><code>assert_eq!(&lt;left&gt;, &lt;right&gt;, &lt;optional message&gt;)</code> asserts left is equal to right or panics with optional message</li>
<li><code>assert_ne!(&lt;left&gt;, &lt;right&gt;, &lt;optional message&gt;)</code> asserts left is NOT equal to right or panics with optional message</li>
</ul>
<p>There are a couple of restrictions with the assert macros. Values used must implement <code>PartialEq</code> and <code>Debug</code>. Most
built in types already implement both, and we‚Äôll talk about how to implement them for your own types in the Traits
chapter.</p>
<blockquote>
<p>You can also find more assert macros for specific types, in Rusts experimental tool chain, and in other libraries.
There are even libraries specifically built for enhancing your tests but these are out of scope for this book.</p>
</blockquote>
<p>To run tests in our project we use <code>cargo test</code>. In the case of the above we should see the following:</p>
<pre><code class="language-text">error: test failed, to rerun pass `--lib`

running 1 test
test tests::test_split_at ... FAILED

failures:

---- tests::test_split_at stdout ----
thread 'tests::test_split_at' panicked at src/lib.rs:6:9:
Intentionally failing a test to show how they work
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::test_split_at

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h2 id="testing-our-code"><a class="header" href="#testing-our-code">Testing our code</a></h2>
<p>Let‚Äôs move on to writing our actual tests, we‚Äôll start with ‚Äúsplit_at‚Äù.</p>
<p>Before we can write a test, <code>split_at</code> is not part of the <code>tests</code> module, so we need to make it available inside. We can
do that with the <code>use</code> statement in one of two ways, either <code>use super::split_at</code> or <code>use super::*</code>. The <code>super</code> keyword
simply means the module above this one, which for your unit tests should be the module to you‚Äôre writing tests for. We
can either bring just the one function in, or we can bring in everything available in that scope. The idiom here is that
your module ideally shouldn‚Äôt be so complicated that you can‚Äôt bring in everything, so it‚Äôs usually safe to
<code>use super::*</code>.</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}
 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_split_at() {
        let input = "Hello, world!";
        let (split_left, split_right) = split_at(input, 3);
        assert_eq!(split_left, "Hel", "First 3 characters");
        assert_eq!(split_right, "lo, world!", "Rest of input");
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c690b50e621e51a775b9ecf2019ee663" title="" target="_blank">Link to tests</a></p>
<p>Congratulations, we now have our first working test! If you mess with the assertions, you can see how the optional
message helps us find the broken assertion faster. And if you read the optional message, it tells us the expected
behaviour‚Ä¶ I think those of you who regularly USE non-english languages will see where the expectation doesn‚Äôt meet
the behaviour.</p>
<p>Let‚Äôs write another test for <code>split_at</code>:</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}
 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_split_at() {
        // ...
<span class="boring">        let input = "Hello, world!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "Hel", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "lo, world!", "Rest of input");
</span>    }
    
    #[test]
    fn test_split_at_multibyte() {
        let input = "„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïåÔºÅ";
        let (split_left, split_right) = split_at(input, 3);
        assert_eq!(split_left, "„Åì„Çì„Å´", "First 3 characters");
        assert_eq!(split_right, "„Å°„ÅØ‰∏ñÁïåÔºÅ", "Rest of input");
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cf9de81995dc46c807e4d08e9cc4c75b" title="" target="_blank">Link to tests</a></p>
<p>This is why setting our expectations of functionality in plain, natural language, is so important!</p>
<p>We‚Äôve explained in the test that we expected to split at the nth character NOT the nth byte. Now that we know this
doesn‚Äôt match the expectations, we should fix our function.</p>
<p>Don‚Äôt worry too much about this next bit yet, but if you‚Äôd like an explanation of the fix</p>
<p>In order to do this, we need to find the byte number where our number of characters is met. Looking at the
documentation for <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars" title="" target="_blank">str</a> we can find there‚Äôs a method
for creating an iterator of chars. For small strings, this feels like an acceptable way to find the new place to split
our string slice. We‚Äôll also use a method called
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take" title="" target="_blank">
<code>take</code></a> that we can use to effectively only take the
first X characters. We‚Äôll then <code>map</code> over each item remaining in the iterator to get its size in bytes, before summing
the number of bytes to get our new split point.</p>
<p>We no longer need the bounds check because, if the <code>at</code> is greater than the length of the string in characters, our
<code>chars</code> iterator will end before we reach the <code>take</code> limit.</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    let byte_count = input.chars().take(at).map(|c| c.len_utf8()).sum();
    (&amp;input[..byte_count], &amp;input[byte_count..])
}
 
#[cfg(test)]
mod tests {
    // ...
<span class="boring">    use super::*;
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_split_at() {
</span><span class="boring">        let input = "Hello, world!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "Hel", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "lo, world!", "Rest of input");
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_split_at_multibyte() {
</span><span class="boring">
</span><span class="boring">        let input = "„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïåÔºÅ";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "„Åì„Çì„Å´", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "„Å°„ÅØ‰∏ñÁïåÔºÅ", "Rest of input");
</span><span class="boring">    }
</span>}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=09d99c5316173b306ad23c4f938a0b54" title="" target="_blank">Link to tests</a></p>
<p>Now this test works too!</p>
<p>Let‚Äôs quickly write the tests for <code>split_around</code> and <code>split_around_many</code>:</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let byte_count = input.chars().take(at).map(|c| c.len_utf8()).sum();
</span><span class="boring">    (&amp;input[..byte_count], &amp;input[byte_count..])
</span>}

fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    // ...
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span>}
 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_split_at() {
        // ...
<span class="boring">        let input = "Hello, world!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "Hel", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "lo, world!", "Rest of input");
</span>    }
    
    #[test]
    fn test_split_at_multibyte() {
        // ...
<span class="boring">        let input = "„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "„Åì„Çì„Å´", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "„Å°„ÅØ‰∏ñÁïå!", "Rest of input");
</span>    }
    
    #[test]
    fn test_split_around() {
        let input = "Hello, world!";
        let (split_left, split_right) = split_around(input, ", ");
        assert_eq!(split_left, "Hello", "First 3 characters");
        assert_eq!(split_right, "world!", "Rest of input");
    }

    #[test]
    fn test_split_around_multibyte() {
        let input = "„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïåÔºÅ";
        let (split_left, split_right) = split_around(input, "‰∏ñÁïå");
        assert_eq!(split_left, "„Åì„Çì„Å´„Å°„ÅØ", "First 3 characters");
        assert_eq!(split_right, "ÔºÅ", "Rest of input");
    }
    
    #[test]
    fn test_split_around_many() {
        let input = "The quick brown fox jumped over the lazy dog";
        let mut collection = Vec::new();
        split_around_many(input, " ", &amp;mut collection);
        assert_eq!(collection, vec![
            "The",
            "quick",
            "brown",
            "fox",
            "jumped",
            "over",
            "the",
            "lazy",
            "dog",
        ]);
    }
    
    #[test]
    fn test_split_around_many_multibyte() {
        let input = "The quick brown „Ç≠„ÉÑ„Éç jumped over the lazy Áä¨";
        let mut collection = Vec::new();
        split_around_many(input, " ", &amp;mut collection);
        assert_eq!(collection, vec![
            "The",
            "quick",
            "brown",
            "„Ç≠„ÉÑ„Éç",
            "jumped",
            "over",
            "the",
            "lazy",
            "Áä¨",
        ]);
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1192fc71d8bf6be488c241a0a7f0a827" title="" target="_blank">Link to tests</a></p>
<p>Note that we didn‚Äôt need to update the other functions for multibyte because we‚Äôre specifically looking for a substring
that either exists or doesn‚Äôt.</p>
<p>Now, what if I told you: we just did all of this backwards üò≤</p>
<h2 id="test-driven-development"><a class="header" href="#test-driven-development">Test Driven Development</a></h2>
<p>So now, hopefully, you‚Äôre eager to write a load of code and then write a load of tests, but wait!</p>
<p>As we alluded to at the top of chapter, and again halfway through, the point of tests isn‚Äôt to test that your code does
what you <em>think</em> it does, it‚Äôs to make sure it does what it‚Äôs <em>supposed</em> to do.</p>
<p>The best way to achieve this is to work out what your code is supposed to do, then write the test, then write the code.
This is called Test Driven Development (TDD).</p>
<p>Let‚Äôs try some TDD. We‚Äôll create a function that checks if a given string is a palindrome (a word that‚Äôs the same
forwards and backwards).</p>
<p>We‚Äôll start by writing our test:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("racecar"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6f6409b54d8e8d3af13086a02030c3f4" title="" target="_blank">Link to tests</a></p>
<p>This won‚Äôt compile though, so in order to run our test (even though it won‚Äôt work), we need to write the function. We
don‚Äôt want to write any code inside it yet though, so we‚Äôll use the <code>todo!()</code> macro.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(_input: &amp;str) -&gt; bool {
    todo!("Implement the palindrome checker");
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        // ...
<span class="boring">        assert!(is_palindrome("kayak"));
</span><span class="boring">        assert!(is_palindrome("racecar"));
</span><span class="boring">        assert!(!is_palindrome("wood"));
</span>    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=64e08f5b84aaf37520679327ae0eb015" title="" target="_blank">Link to tests</a></p>
<p>We use the <code>todo!</code> macro to state we are intending to come back and fix this code soon. It works even in our function
that‚Äôs supposed to return a boolean because Rust recognises that the todo macro will kill the program, and therefore the
function can will never return.</p>
<p>We‚Äôve also used an underscore on the front of the <code>_input</code> parameter just to let Rust know that <em>we</em> know that parameter
isn‚Äôt used yet (otherwise it‚Äôll warn us about it).</p>
<p>Let‚Äôs think about our implementation. The string slice type doesn‚Äôt have a reverse method built in to it and even if it
did, that would require allocating memory. Instead, lets use the chars iterator like we did earlier, we‚Äôll create two
iterators, reverse one of them, then zip them together. If every character matches its counterpart then the string is
a palindrome.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    let forward = input.chars();
    let backward = forward.clone().rev();
    forward.zip(backward).all(|(f, b)| f == b)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("race car"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=29b7f57a396eef9d06d0d0c501bd3e8c" title="" target="_blank">Link to tests</a></p>
<blockquote>
<p>‚ÑπÔ∏è Curiously, cloning an iterator does not necessarily cause a memory allocation. In this case we‚Äôre safe, but it can
be worth checking these things when speed and efficiency are important.</p>
</blockquote>
<p>And now our test passes! But, uh-oh, when we send the code to be reviewed by a peer, they point out ‚Äúracecar‚Äù isn‚Äôt a
word. They do think that ‚Äúrace car‚Äù (with a space) should be considered a palindrome, so we update our test, but now it
fails.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    // ...
<span class="boring">    let forward = input.chars();
</span><span class="boring">    let backward = forward.clone().rev();
</span><span class="boring">    forward.zip(backward).all(|(f, b)| f == b)
</span>}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("race car"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=55ca613fc48720fe1b2ab48370ccf866" title="" target="_blank">Link to tests</a></p>
<p>Now we broke our test, lets fix the code. This one is easy, we just ignore anything that‚Äôs not a letter or a number.
We can do this by adding a filter to the iterator.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    let forward = input.chars().filter(|c| c.is_alphanumeric());
    let backward = forward.clone().rev();
    forward.zip(backward).all(|(f, b)| f == b)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("race car"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0b7ab806e298c477989d64dd899985b3" title="" target="_blank">Link to tests</a></p>
<p>And we‚Äôve fixed the code. The person reviewing the code is happy, so it goes out to customers, but someone complains.
Their name is Anna, which is an anagram. We add it to the test:</p>
<pre><code class="language-rust noplayground"><span class="boring">fn is_palindrome(input: &amp;str) -&gt; bool {
</span><span class="boring">    let forward = input.chars().filter(|c| c.is_alphanumeric());
</span><span class="boring">    let backward = forward.clone().rev();
</span><span class="boring">    forward.zip(backward).all(|(f, b)| f == b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    
</span>#[test]
fn test_is_palindrome() {
    assert!(is_palindrome("kayak"));
    assert!(is_palindrome("race car"));
    assert!(!is_palindrome("wood"));
    assert!(is_palindrome("Anna"));
}
<span class="boring">}</span></code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=62e10f1d7a723de4637d560c5153219c" title="" target="_blank">Link to tests</a></p>
<p>Capital letters are a little more complex as an uppercase character might be the same for multiple lowercase characters.
When we call <code>.to_lowercase()</code> on a character in Rust, it will return an iterator for each character that could
conceivably be turned into that uppercase character. If we map over each character and use <code>.to_lowercase()</code> then we
have an iterator of iterators of characters. We can flatten this out with the <code>.flatten()</code> method to turn it back into
an iterator of characters. Because we use <code>.rev()</code> after this point, it should still work with strings that contain
characters that could have multiple lowercase counterparts.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    let forward = input
        .chars()
        .filter(|c| c.is_alphanumeric())
        .map(|c| c.to_lowercase())
        .flatten();
    let backward = forward.clone().rev();
    forward.zip(backward).all(|(f, b)| f == b)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_is_palindrome() {
</span><span class="boring">        assert!(is_palindrome("kayak"));
</span><span class="boring">        assert!(is_palindrome("race car"));
</span><span class="boring">        assert!(!is_palindrome("wood"));
</span><span class="boring">        assert!(is_palindrome("Anna"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e012e666c1862768da409a7995116cfe" title="" target="_blank">Link to tests</a></p>
<p>This function still isn‚Äôt perfect, but it works for the given test conditions.</p>
<blockquote>
<p>If you want to continue developing this function to include things like diacritics, please do! But, you will need to
start using external crates which is out of scope of this section of the book.</p>
</blockquote>
<h2 id="how-many-tests-should-a-good-test-writer-write-if-a-good-test-writer-could-write-good-tests"><a class="header" href="#how-many-tests-should-a-good-test-writer-write-if-a-good-test-writer-could-write-good-tests">How many tests should a good test writer write if a good test writer could write good tests?</a></h2>
<p>The perennial of questions when it comes to testing: How many tests should you write?</p>
<p>The important thing here is ‚Äúcoverage‚Äù. Do you have a test that ‚Äúcovers‚Äù each line of code.</p>
<p>Take for example this really silly function:</p>
<pre><code class="language-rust noplayground">fn is_positive(num: i32) -&gt; bool {
    if num &gt; 0 {
        true
    } else {
        true
    }
}</code></pre>
<p>If we only test this function by giving it a number greater than 0, we‚Äôll only ‚Äúcover‚Äù the line first branch of the
<code>if</code>, we miss the fact there is a mistake in the second branch.</p>
<p>So what percent coverage should you aim for?</p>
<p>Anecdotally, when I was creating my own API framework in PHP, I decided I wanted to get 100% coverage, that is, every
line should have a test that hits it. The very last lime that was uncovered was:</p>
<pre><code class="language-php ignore">        }
</code></pre>
<p>I wondered if it was worth the effort, decided it was. The reason this was the last uncovered line was that it was part
of a nested <code>if</code>. I‚Äôd tested what happens if you went into both <code>if</code>s, what happens if you didn‚Äôt go into the first, but
not what happens if you went into the first, but not the second.</p>
<pre><code class="language-php">function example() {
    if first_condition {
        if second_condition {
            return do_something();
        }
    } // &lt;- It was this line
    return do_something_else();
}
</code></pre>
<p>I wrote the test and‚Ä¶ found a bug so severe that I had to rewrite almost a third of the framework. Should have written
the tests first, right?</p>
<p>My personal feelings are that you as an engineer should strive for 100% coverage of your code.</p>
<p>As a manager or engineering lead though, test coverage is a terrible metric. Test coverage doesn‚Äôt tell you if the test
was any good. If you make arbitrary metrics like this, you‚Äôre not improving code quality, engineers will write tests
that meet that metric, but don‚Äôt for-fill the reason we want tests in the first place which is to answer: ‚Äúdoes this
code do what we want it to do?‚Äù.</p>
<p>As an engineer, it‚Äôs a matter of pride. Get your code right now, and you won‚Äôt have to deal with it later. As a leader,
make sure your engineers are encouraged to be the best they can. That means giving them the time to write tests first,
giving them access to the resources they need to learn how to write the best tests, etc.</p>
<h2 id="homework"><a class="header" href="#homework">Homework</a></h2>
<p>We‚Äôve already let on how you can solve last chapters homework:</p>
<pre><code class="language-rust noplayground">fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    if let Some(found_at) = input.find(sub_string) {
        let end_pos = found_at + sub_string.len();
        collection.push(&amp;input[..found_at]);
        split_around_many(&amp;input[end_pos..], sub_string, collection);
    } else {
        collection.push(&amp;input);
    }
}</code></pre>
<p>We only needed one lifetime to represent the link between the input string slice and the string slice inside our vector.</p>
<p>For a cleaner API though you could keep our recursive function private and expose a public function that creates the
vector for us. Because we have control of the vector in this example we can make sure we create a vector with a capacity
that is at least as large as the maximum possible entries in it. This is useful as when you create a new Vector in Rust
it has a default size, and any time you try to add an item to a vector that is already full, Rust will allocate the
memory for a new larger vector in the background, copy the data from the old location to the new location, then free the
memory in the old location.</p>
<pre><code class="language-rust noplayground">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    // ...
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span>}

pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut output = Vec::with_capacity(input.matches(sub_string).count());
    split_around_many_recurse(input, sub_string, &amp;mut output);
    output
}</code></pre>
<p>For the homework in this chapter, I would like you to write the tests for, and then implement the code for the following
requirements in this order:</p>
<ol>
<li>Create a function that will reverse the words in an English sentence.</li>
<li>If the string started with a capital letter, it should still start with a capital after the words are reversed.</li>
<li>If the string starts or ends with whitespace, it should be removed (trimmed) from the returned String.</li>
<li>If the string contains more than one sentence, the function should return an error (though for now, that error can
be the unit type <code>()</code>).</li>
</ol>
<p>Your function will need to allocate memory and should probably have the header:</p>
<pre><code class="language-rust ignore">fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt;</code></pre>
<p>Here is the documentation on <a href="https://doc.rust-lang.org/std/string/struct.String.html" title="" target="_blank">String</a> and
<a href="https://doc.rust-lang.org/std/result/enum.Result.html" title="" target="_blank">Result</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
