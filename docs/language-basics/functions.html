<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->
        <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="../introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="../getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="../language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language-basics/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="../language-basics/data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../language-basics/control-flow.html"><strong aria-hidden="true">3.3.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../language-basics/functions.html" class="active"><strong aria-hidden="true">3.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../language-basics/tests.html"><strong aria-hidden="true">3.5.</strong> Tests</a></li><li class="chapter-item expanded "><a href="../language-basics/documentation.html"><strong aria-hidden="true">3.6.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="../language-basics/clippy-and-fmt.html"><strong aria-hidden="true">3.7.</strong> Clippy and Fmt</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> Traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Conversions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Common Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are reusable blocks of code. They have inputs, usually perform some sort of process, then have an output.</p>
<p>We‚Äôve been using a function called <code>main</code> to run all of our programs and examples so far. This is a special function
that is called as the program starts. We‚Äôve also used a few other kinds of functions and methods (special functions
attached to data types) that are built into Rust. We can make and use our own functions too though.</p>
<p>Functions can be pure, or impure. A pure function takes an input, does some processing and returns an output. This makes
the function extremely predictable. Given the same input they will always produce the same output, and nothing else
within the system will change.</p>
<style>
  .mermaid {
    text-align: center;
  }
  .mermaid svg {
    background-color: white;
  }
</style>
<pre class="mermaid">---
title: Pure Function
---
graph LR;
    Input ==&gt; Process
    Process ==&gt; Output
</pre>
<p>An impure function, might not always produce the same output given the same input, or may have side effects within the
system, either changing something else in the system or having some other part of the system change what the function
does.</p>
<pre class="mermaid">---
title: Impure Function
---
graph LR;
    Input ==&gt; Process
    Process ==&gt; Output
    Process &lt;-.-&gt; SE[&quot;Side Effect&quot;]
    
</pre>
<h2 id="a-quick-note-on-mutability"><a class="header" href="#a-quick-note-on-mutability">A Quick Note on Mutability</a></h2>
<p>Up to now, we haven‚Äôt needed to change any data once it‚Äôs been created. By default, all variables in Rust are implicitly
‚Äúimmutable‚Äù, meaning that the values inside of them can not be changed.</p>
<p>This, for example, won‚Äôt compile (try to run it to see the compiler output)</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let one = 1;
one = one + 1;
<span class="boring">println!("one = {one}");
</span><span class="boring">}</span></code></pre></pre>
<p>Immutability is good because it prevents data from being changed by mistake which, going on the name of the variable in
the above example, is obviously what‚Äôs happened here (ie, it seems like <code>one</code> should probably not contain <code>2</code>).</p>
<p>It‚Äôs good to use immutable variables as much as possible, but software needs to be able to process data. If we could
never mutate values, we‚Äôd always have to depend on creating copies like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let one = 1;
let two = one + 1;
<span class="boring">println!("two = {two}");
</span><span class="boring">}</span></code></pre></pre>
<p>That‚Äôs fine for small data but imagine we‚Äôre processing large data like an image. Do we want to copy it every time we
make a single pixel change?</p>
<p>You can explicitly opt in to mutability by adding the word <code>mut</code> (pronounced ‚Äúmute‚Äù) in front of the variable name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut message = "Hello".to_string();
message.push_str(", world!"); // Modify message by adding this data to the end
<span class="boring">println!("{message}");
</span><span class="boring">}</span></code></pre></pre>
<h2 id="creating-and-calling-functions"><a class="header" href="#creating-and-calling-functions">Creating and calling functions</a></h2>
<p>Functions are defined with the <code>fn</code> keyword (short for FuNction), followed by a name, followed by brackets <code>()</code> which
may or may not contain parameters, possibly followed by an arrow <code>-&gt;</code> and a return type (if no return type is specified
the return type is the Unit Type <code>()</code>, see the <a href="./data-types.html#the-unit-type">data types chapter</a>). This part of the
function is called the ‚Äúfunction header‚Äù. The function is completed by a code block, code between curly brackets, which
is also called the function body.</p>
<p>So lets create the simplest possible function:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello() {
    println!("Hello, world");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello();
</span><span class="boring">}</span></code></pre></pre>
<p>This function is called <code>say_hello</code>, it has no parameters and does not return anything. Because it writes to the
terminal, this function is considered to be impure.</p>
<p>We can call the function using its name and empty brackets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello() {
</span><span class="boring">    println!("Hello, world");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello();
}</code></pre></pre>
<p>You‚Äôll notice this function doesn‚Äôt actually have any inputs or outputs. Let‚Äôs start by providing an input.</p>
<h2 id="passing-parameters"><a class="header" href="#passing-parameters">Passing Parameters</a></h2>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: &amp;str) {
    println!("Hello, {name}");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello("Yuki");
</span><span class="boring">}</span></code></pre></pre>
<p>Now the function has one input (we call it a parameter) called <code>name</code>. You can see that we also provide type information
for the parameter, in this case it‚Äôs a string slice (<code>&amp;str</code>). The parameter can be used as a variable within the
function, so we use it in our <code>println!</code>.</p>
<p>To pass the data into the function we place it between the brackets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello("Yuki");
}</code></pre></pre>
<p>We can have multiple parameters too. Parameters are ordered so when you call the function, you need to match the order
they‚Äôre specified. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello_two(first_person: &amp;str, second_person: &amp;str) {
    println!("Hello, {first_person} and {second_person}");
}

fn main() {
    say_hello_two("Indra", "Yuki");
}</code></pre></pre>
<h2 id="returning-from-functions"><a class="header" href="#returning-from-functions">Returning from Functions</a></h2>
<p>Let‚Äôs fix our function to remove the side effect. Instead of directly printing to the terminal from the function, we‚Äôll
return the string we want to display and move the side effect to main.</p>
<p>We‚Äôll make the following changes:</p>
<ul>
<li>We‚Äôll rename the function to reflect the change in behaviour (see <a href="#best-practices">Best Practices</a> below)</li>
<li>We‚Äôll add the return type (in this case <code>String</code>) to the function header, after <code>-&gt;</code></li>
<li>We‚Äôll create the String using the <code>format!</code> macro and store it in a variable <code>message</code> (note: the variable isn‚Äôt
necessary, it‚Äôs just for clarity)</li>
<li>We‚Äôll return the <code>message</code> from the function, remember the code blocks can be expressions, we don‚Äôt need to explicitly
write <code>return</code> (though we can), we just need to make the thing we want to return the last bit of the block and forgo
the semicolon</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
    let greeting = create_greeting("Yuki");
    println!("{greeting}");
}</code></pre></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>See also: <a href="#recursion">recursion</a></p>
<p>In Rust, functions can call other functions, like how our <code>main()</code> function calls our <code>create_greeting(...)</code> function in
the previous example. A function that calls itself is described as recursive. Take for example this method for finding
the nth number in the fibonacci sequence</p>
<pre><pre class="playground"><code class="language-rust">fn find_fibonacci(n: u128) -&gt; u128 {
    if n == 0 || n == 1 { // if n equals 0 or n equals 1
        n
    } else {
        find_fibonacci(n - 1) + find_fibonacci(n - 2)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let n = 11;
</span><span class="boring">    let fibonacci = find_fibonacci(n);
</span><span class="boring">    println!("The {n} value of fibonacci is {fibonacci}");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note in this function that we use a boolean OR (<code>||</code>) in the <code>if</code> so the larger expression evaluates to true if either
the left or right parts of the expression evaluate to true. I.e. the expression is true if n is equal to 0 OR if n is
equal to 1.</p>
<p>We also use the <code>if</code>/<code>else</code> as an expression so the return of the function is equal to the values in the <code>if</code>/<code>else</code>
blocks. If the expression in the <code>if</code> is true, then we return <code>n</code>, otherwise we return the result of calling the same
function with new parameters.</p>
</blockquote>
<p>Because we call <code>find_fibonacci</code> inside of <code>find_fibonacci</code>, this is a recursion. Each time we call the function in this
way, we add another layer on <a href="./memory.html">the stack</a>. The stack is finite, so if we give the function a
large enough number, it will eventually run out of space in the stack, causing a stack overflow, and you‚Äôll see
something like:</p>
<pre><code class="language-text">thread 'main' has overflowed its stack
</code></pre>
<blockquote>
<p>Its worth noting I had to manually set the stack size to something unreasonably small</p>
</blockquote>
<p>Rust does support ‚Äútail recursion‚Äù which is technique for turning a recursive function into a loop at compile time. This
not only minimises stack usage to effectively a single function call but is also much faster. However, I think this is
an overrated feature. In any language that supports tail recursion, it‚Äôs hard to guarantee the compiler will optimise
this way, and it‚Äôs easy to break. My recommendation is if you need to recurse a <em>lot</em>, then consider whether you can
manually rewrite your function as a loop instead of depending on a compiler optimization.</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<h3 id="memory-management-primer"><a class="header" href="#memory-management-primer">Memory Management Primer</a></h3>
<p>Variables in Rust have to live somewhere in physical memory. This primarily comes down to the Stack, the Heap and the
binary (for a deeper explanation, see the <a href="memory.html">chapter on memory</a>). The Heap can be thought of as managed. You
ask the operating system (or other memory manager) to ‚Äúallocate‚Äù you a block of memory to use for writing to and reading
from, before finally ‚Äúfreeing‚Äù that block and returning the memory to the operating system.</p>
<p>In some programming languages, this memory is managed manually by you. You have to ask for the memory and free it
yourself. This leads to some problems:</p>
<ul>
<li>What happens if you try to use memory that wasn‚Äôt allocated?</li>
<li>What happens if you try to use memory that you already freed?</li>
<li>What happens if you try to store more data than fits?</li>
</ul>
<p>Not only is it surprisingly easy to make mistakes here, the consequences can be severe: around 70% of all security
vulnerabilities are caused by accidental misuse of memory.</p>
<p>In order to get around these problems, some programming languages use an automated method of memory management called
garbage collection. In this method, you, the software engineer, don‚Äôt have to think about the actions required to get
or return memory to/from the operating system. Instead, as memory is allocated, the garbage collector built into the
language, will monitor to see which parts of your program are actively looking at that bit of memory, through a process
called reference counting. Once the number of places using that data has dropped to zero, the garbage collector can
safely free the memory.</p>
<p>This is much safer than manually managing the memory yourself, but comes with some of its own problems:</p>
<ul>
<li>The garbage collector requires additional resources to manage memory
<ul>
<li>This includes CPU time to do the work but in some cases can also require significantly more memory</li>
</ul>
</li>
<li>Managing memory by proxy is less efficient than managing it directly, meaning its slower</li>
<li>You have limited to no control over what the garbage collector does or when it does it, this can have big negative
impacts to performance at uncontrollable times</li>
</ul>
<p>Rust‚Äôs method of memory management is a little different. It‚Äôs low level, giving you the speed of manual memory
management, but its mechanisms are hidden behind abstractions that mitigate its risks. It‚Äôs certainly not as easy to
learn, but once you get your head around it, it makes a lot of sense.</p>
<h3 id="introducing-ownership"><a class="header" href="#introducing-ownership">Introducing Ownership</a></h3>
<p>In Rust, all data is ‚Äúowned‚Äù. When the variable that ‚Äúowns‚Äù the data goes out of scope, the data is dropped. This means
that if the data was stored on the Heap, then that bit of memory is immediately freed.</p>
<p>Let‚Äôs have a play with this, first, lets look at the scope aspect of ownership:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
  let a = 'a'; // We create `a` in the outer scope of "main"

  { // Start of a new block, starting a nested scope

    println!("{a}"); // This works as `a` is in scope

    let b = 'b'; // We create `b` in the inner scope of this code block
    println!("{b}"); // This works as `b` is in scope

  } // End of the block, b goes out of scope

  println!("{a}"); // This still works as `a` is still in scope
  println!("{b}"); // This does not work as `b` went out of scope
}</code></pre></pre>
<p>We can see that once a variable is out of scope, it can‚Äôt be used. If you run the above example (remember, you can do
that in this book by mousing over the example and hitting the play button), you‚Äôll see it won‚Äôt compile and (amongst
a few other bits) gives you this message:</p>
<pre><code class="language-text">error[E0425]: cannot find value `b` in this scope
  --&gt; src/main.rs:14:14
</code></pre>
<p>Which tells us <em>exactly</em> what‚Äôs wrong! Rust‚Äôs compiler messages generally amazing, especially when it comes to working
with ownership, so it‚Äôs worth getting used to how Rust presents its errors.</p>
<p>Next, lets look at how data can only be ‚Äúowned‚Äù by one thing at a time:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let a = "hello".to_string(); // We create some data and give it to `a`
let b = a;                   // We give the data in `a` to `b`, transfering ownership
println!("{b}");             // This would be fine as b owns "hello"
println!("{a}");             // This won't compile, the data "moved" from `a` to `b`
<span class="boring">}</span></code></pre></pre>
<p>The statement <code>let b = a;</code> ‚Äúmoves‚Äù ownership of the string from <code>a</code> to <code>b</code>. Normally we wouldn‚Äôt ‚Äúmove‚Äù data in this way
(spoilers: this is, after all, a chapter on functions), but it neatly shows that the data can‚Äôt be owned by multiple
variables at once.</p>
<h3 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h3>
<p>You might have noticed that we swapped from <code>char</code>s in the first ownership example to a <code>String</code> in the second. This is
because there are two mechanisms at play: ‚ÄúMove‚Äù and ‚ÄúCopy‚Äù.</p>
<p>Let‚Äôs try the same code with chars:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = 'Èõ™';    // We create some data and give it to `a`
let b = a;       // We set b to be equal to a
println!("{b}"); // Prints Èõ™ 
println!("{a}"); // Also prints Èõ™
<span class="boring">}</span></code></pre></pre>
<p>This works! But String didn‚Äôt‚Ä¶ ü§î</p>
<p>The reason for this is that <code>char</code> is Copy, that is to say that it has the <code>Copy</code> trait. We‚Äôll talk more about Traits
in a future chapter, but essentially Traits provide behaviour to Data. Things can have the <code>Copy</code> trait applied to them
if they can be trivially copied and this usually (always?) means the data exists on the stack. The reason for this is
all that ‚Äúallocating‚Äù and ‚Äúfreeing‚Äù memory on the stack we talked about earlier requires a non-trivial amount of time
and resources.</p>
<p>When data has the Copy trait, instead of being moved from one variable to another, it‚Äôs copied. This mechanism on data
that is Copy is implicit. Data that does not or can not implement Copy may still be duplicated if it implements the
trait <code>Clone</code>, which provides the <code>.clone()</code> method. We‚Äôll talk more about implementing traits in the traits section,
but <code>String</code> already implements this so here‚Äôs how to use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = "hello".to_string(); // We create some data and give it to `a`
let b = a.clone();           // Allocates memory on the heap and copies the data into it
println!("{b}");             // Prints "hello"
println!("{a}");             // Also prints "hello"
<span class="boring">}</span></code></pre></pre>
<p>You‚Äôll also note that we used a full fat <code>String</code> here, not a string slice reference. Here‚Äôs what that would look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = "hello";   // `a` is a reference to data that exists in the binaries "data"
let b = a;         // references are Copy so the reference is copied from a to b
println!("{b}");   // Prints "hello"
println!("{a}");   // Also prints "hello"
<span class="boring">}</span></code></pre></pre>
<p>Because <code>"hello"</code> exists inside the binaries data you can not ‚ÄúOwn‚Äù it. Ownership would imply that once its no longer
used it can be freed, but as its part of the binary, that wouldn‚Äôt make sense. Instead, we just get a reference to where
the value exists in memory. This reference is also immutable, you can‚Äôt change values in the binary. Immutable
references <em>are</em> Copy though.</p>
<p>What does this have to do with functions though?</p>
<h3 id="functions-and-ownership"><a class="header" href="#functions-and-ownership">Functions and Ownership</a></h3>
<p>When we pass data into functions through the use of parameters, the data follows the rules of move semantics.</p>
<p>Let‚Äôs go back to our <code>create_greeting()</code> function. Instead of passing in a string slice reference, what would happen if
we passed in a <code>String</code>?</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn create_greeting(name: String) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
  let yuki = "Yuki".to_string();
  let message = create_greeting(yuki);
  println!("{message}"); // This would be fine but...
  println!("{yuki}"); // This won't compile
}</code></pre></pre>
<p>In the above example, we moved ownership of the data stored in the variable <code>yuki</code> into the parameter <code>name</code> in the
function <code>create_greeting</code>. This means after the function the variable <code>yuki</code> can no longer be used.</p>
<p>Because the <code>format!</code> macro does not take ownership of the data in <code>name</code>, we could return both the message <em>and</em> the
original <code>String</code> data using a tuple.</p>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: String) -&gt; (String, String) {
    let message = format!("Hello, {name}");
    (message, name)
}

fn main() {
  let yuki = "Yuki".to_string();
  let (message, yuki) = create_greeting(yuki);
  println!("{message}"); 
  println!("{yuki}"); // This works again
}</code></pre></pre>
<p>We‚Äôve changed our <code>create_greeting()</code> function to return a tuple that includes both strings. When the function returns
we destructure the tuple (see <a href="control-flow.html">destructuring with patterns</a>) into two new variables,
<code>message</code> and <code>yuki</code>. Note: this new <code>yuki</code> is a different variable from the old <code>yuki</code>, this is called ‚Äúshadowing‚Äù.</p>
<p>This is obviously a terrible way to deal with ownership. Going back to our original function, you can see that we are
taking a reference to a string slice instead. The <code>String</code> type can be ‚Äúdereferenced‚Äù into a reference to a string slice
(remember the internal representation of a String is the same as a string slice), so we can create a reference to our
<code>yuki</code> <code>String</code> using an ampersand:</p>
<pre><pre class="playground"><code class="language-rust">// Changed back to taking a &amp;str
fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
  let yuki = "Yuki".to_string();
  let message = create_greeting(&amp;yuki);
  println!("{message}");
  println!("{yuki}"); // Yuki's ownership was never moved so this now works
}</code></pre></pre>
<p>Let‚Äôs say we wanted our function to modify the string instead. Ideally we‚Äôd want to avoid modifying data that‚Äôs passed
to a function but sometimes that‚Äôs not possible, if you need to do it you can pass a mutable reference.</p>
<pre><pre class="playground"><code class="language-rust">// Change &amp;str to &amp;mut String
fn create_greeting(greeting: &amp;mut String, name: &amp;str)  {
    greeting.push_str(", ");
    greeting.push_str(name);
}

fn main() {
  let mut greeting = "Hello".to_string();
  let name = "Yuki".to_string();
  create_greeting(&amp;mut greeting, &amp;name);
  println!("{greeting}");
}</code></pre></pre>
<p>Some things to note:</p>
<ul>
<li>In order to mutate greeting via a mutable reference, the variable itself must also be mutable: <code>let mut greeting ...</code></li>
<li>When we pass the reference, we are explicit that we are allowing the reference to be mutable too:
<code>create_greeting(&amp;mut greeting, ...)</code></li>
<li>The function takes a mutable reference to a String, not a string slice, as string slices are not mutable, but Strings
are.</li>
</ul>
<p>Finally, when it comes to references, you can have as many immutable references to a value as you like, OR a single
mutable reference. Mutable references are not Copy.</p>
<h3 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h3>
<p>So far so clear, but it turns out that keeping track of those references is actually quite hard.</p>
<p>Let‚Äôs create a function that takes a reference to a string and returns two parts to that string:</p>
<pre><pre class="playground"><code class="language-rust">fn split(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
  let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
  (&amp;input[..up_to], &amp;input[up_to..])
}

fn main() {
  let input = "yuki".to_string();
  let (left, right) = split(&amp;input, 2);

  println!("Input: {input}"); // yuki
  println!("Left:  {left}");  // yu
  println!("Right: {right}"); // ki
}</code></pre></pre>
<blockquote>
<p>Note, we are taking a sub slice of the input string using ranges. <code>&amp;input[..up_to]</code> means the subslice starts at the
beginning of the string and runs up to, but does not include the ‚Äúup_to‚Äúth element (remember indexing starts at 0, so
if up_to is 2, then the sub slice includes bytes 0 and 1 but not 2). <code>&amp;input[up_to..]</code> starts at the ‚Äúup_to‚Äúth byte
and continues until the end of the ‚Äúinput‚Äù slice. Also note that these are ranges of bytes, not characters so there is
a danger here if using multibyte characters. Try not to split strings like this as it‚Äôs not guaranteed the result is a
valid utf-8 string.</p>
</blockquote>
<p>The function split takes a reference to a string, a point to split at, and the returns everything on the left of the
split and everything on the right. The cool thing here is that the string isn‚Äôt duplicated, the values <code>left</code> and
<code>right</code> are references that point to the inside of our input string!</p>
<p>How does Rust know that though? Let‚Äôs confuse it a bit.</p>
<p>Instead of splitting at a particular point, we‚Äôll find a sub string inside the input string, then split around that:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn split(input: &amp;str, sub_string: &amp;str) -&gt; (&amp;str, &amp;str) {
  if let Some(found_at) = input.find(sub_string) {
    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
  } else {
    (&amp;input[..], &amp;input[input.len()..])
  }
}

fn main() {
  let input = "yuki".to_string();
  let sub_string = "uk";
  let (left, right) = split(&amp;input, sub_string);

  println!("Input: {input}"); // yuki
  println!("Left:  {left}"); // y
  println!("Right: {right}"); // i
}</code></pre></pre>
<p>This example won‚Äôt compile, we get the error: <code>expected named lifetime parameter</code>, what does that mean?</p>
<p>We also get guidance from the Rust compiler on how to fix our problem, and what it suggests will work, but once you
understand the problem, you‚Äôll see there‚Äôs a better way to solve it.</p>
<p>A lifetime is Rust‚Äôs way of tracking reference usage. A reference needs to be tied back to its owning variable and this
relationship must be understood at compile time.</p>
<p>Remember the stack? Let‚Äôs tie what we know about ownership to what we know about the stack.</p>
<ul>
<li>Some data is stored on the stack, some is stored on the heap</li>
<li>Heap data is tied back to variables on the stack that ‚Äúown‚Äù the heap data</li>
<li>As we enter a function, all the space required for the stack data is added to the top of the stack</li>
<li>Further functions go up the stack</li>
<li>As functions come to an end they are removed from the top of the stack</li>
<li>Owned data that is not returned down the stack is freed</li>
</ul>
<p>When it comes to references, we need to make sure that a reference to owned data does not out live the owned data.</p>
<p>For example, lets create a string on the heap called <code>my_string</code>. We‚Äôll then return a reference to that string, but not
the string itself. This would mean that when the function comes to an end, the variable <code>my_string</code> goes out of scope,
so the data that it owns on the Heap is freed‚Ä¶ what would our reference point at now? Luckily Rust won‚Äôt let us do
this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bad() -&gt; &amp;str {
  let my_string = "Oh no!".to_string();
  &amp;my_string
}
<span class="boring">}</span></code></pre></pre>
<p>In order to prevent this, Rust tracks the lifetimes of each reference and its owned data. It can often do this
automatically. In the first version of our function Rust can see that only one reference enters the function, no other
references are in play, so Rust knows that the two references that are returned <em>must</em> be tied to the same data as the
incoming reference.</p>
<p>In the second version of our function, we pass two references in, now Rust is now less sure about which data the
returned references should be tied to. The suggestion the Rust compiler gives us is to tie all the references to the
same lifetime. This actually is a valid approach as Rust will use the shortest living bit of data to tie the references
to.</p>
<p>Let‚Äôs do what it says. Rust lifetimes are annotated with generic labels. If we‚Äôre being lazy we might use a single
lettered label like <code>'a</code>, though if a lot of lifetimes are at play it‚Äôs definitely better to use longer, clearer labels.</p>
<p>We‚Äôll change the header of our function to include the lifetime <code>'a</code>. First we tell Rust we want to use a lifetime by
putting it inside triangle brackets after the function name. Then we mark each reference with that lifetime.</p>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let input = "yuki".to_string();
</span><span class="boring">  let sub_string = "uk";
</span><span class="boring">  let (left, right) = split(&amp;input, sub_string);
</span><span class="boring">
</span><span class="boring">  println!("Input: {input}"); // yuki
</span><span class="boring">  println!("Left:  {left}"); // y
</span><span class="boring">  println!("Right: {right}"); // i
</span><span class="boring">}</span></code></pre></pre>
<p>You can run the above and see this example works just fine, however, it‚Äôs not ideal. We‚Äôve tied all the references to
the same lifetime. The following shows that we can‚Äôt compile code that we know should work.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">    } else {
</span><span class="boring">        (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let input = "yuki".to_string();

let (left, right) = {
    let sub_string = "uk".to_string();
    split(&amp;input, &amp;sub_string)
};

println!("Input: {input}"); // yuki
println!("Left:  {left}"); // y
println!("Right: {right}"); // i
<span class="boring">}</span></code></pre></pre>
<p>This is contrived but here we‚Äôve created an inner scope for our sub string. When that scope ends, that substring will be
freed. You and I know that the left and right references are tied to the input variable in the outer scope, but we told
Rust that it should tie all the lifetimes together. Since the sub string lasts the least amount of time, that‚Äôs the
lifetime it used.</p>
<p>To fix this problem we can just remove the lifetime annotation from the sub_string parameter. Now everything works
as we‚Äôd expect:</p>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
  // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + 1..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn main() {
    let input = "yuki".to_string();
    
    let (left, right) = {
        let sub_string = "uk".to_string();
        split(&amp;input, &amp;sub_string)
    };
    
    println!("Input: {input}"); // yuki
    println!("Left:  {left}"); // y
    println!("Right: {right}"); // i
}</code></pre></pre>
<p>References and lifetimes get really tricky. Here‚Äôs how I like to think about them. Imagine a person flying a kite. The
person is the owner of the data, the kite is the reference, and the string tying them together is the lifetime.</p>
<p>The kite can go up and down the stack freely, but it can‚Äôt go below where the person is standing, that‚Äôs the equivalent
of the ground.</p>
<p>Multiple people can fly their kites through the same functions, and each one has its own kite string (lifetime).</p>
<p>Its even possible to entwine the kites. Imagine a function that takes two string references and returns the longest.
This is like a function that accepts two kites but only the largest is returned. Because you don‚Äôt know who that kite
belongs to, it can‚Äôt go below the person standing highest on the stack.</p>
<p>Lifetimes can be incredibly powerful, there‚Äôs no need to fear them. One amazing example is that you can have a string
that contains some data, for example it could be a serialized format like JSON or YAML, or it could be something like
an Advent of Code input string. Lifetimes mean that you bring that String into your program, allocating the memory for
it once, then turn it into a complex data structure. So long as the original String exists, the data structure can need
not allocate any further memory, which is incredibly efficient.</p>
<pre><pre class="playground"><code class="language-rust">struct User&lt;'a&gt; {
  name: &amp;'a str,
  fur_color: &amp;'a str,
}


fn parse_user&lt;'a&gt;(input: &amp;'a str) -&gt; User&lt;'a&gt; {
    // ...
<span class="boring">    // ok, you caught me, this isn't a real parser
</span><span class="boring">    let mut iter = input.lines();
</span><span class="boring">    let name = &amp;iter.next().unwrap()[6..];
</span><span class="boring">    let fur_color = &amp;iter.next().unwrap()[5..];
</span><span class="boring">    User {
</span><span class="boring">      name,
</span><span class="boring">      fur_color,
</span><span class="boring">    }
</span>}

fn main() {
    let user = "name: Yuki
fur: white"
            .to_string();
    let User { name, fur_color } = parse_user(&amp;user);
    println!("User {name} is a {fur_color} cat");
}</code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>Here are some best practices when it comes to working with functions:</p>
<ul>
<li>Create a function whenever a section of code can be described in a few words</li>
<li>The function name should describe what that code is doing</li>
<li>Functions should only do one thing, avoid big branches inside functions</li>
<li>Keep functions short, but not too short. Functions should be set of instructions grouped together, too few, and it may
not be worth the function, too many, and it may need to be broken down into more functions</li>
<li>Do not take ownership unless you expressly need to own the data</li>
<li><em>Try</em> to avoid mutable parameters</li>
<li>Be specific about your lifetimes, if using more than one or two, try naming them</li>
</ul>
<h2 id="homework"><a class="header" href="#homework">Homework</a></h2>
<p>This time I‚Äôd like you to create a function that splits our string like before, but instead of returning a left and
right side it splits every part of the string.</p>
<p>There is already a split method on string slices, but I‚Äôd like you to only use find, and create a recursive function.</p>
<p>You‚Äôll need to use a collection type to store all the chunks created by the split, I suggest using <code>Vec</code> (see the
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" title="" target="_blank">Documentation</a>) which is built into Rusts standard library.</p>
<p>A Vec is a variably sized array that you can push new items on to the end of using the <code>.push(...)</code> method.</p>
<p>To check whether your Vec contains the correct information after the program has run, use the <code>dbg!</code> macro (we‚Äôll talk
more about how this works another time, all you need to know is it will work for a Vec of string slice references).</p>
<p>The header of your function might look something like this:</p>
<pre><code class="language-rust ignore">fn split(input: &amp;str, split_at: &amp;str, collection: &amp;mut Vec&lt;&amp;str&gt;)</code></pre>
<p>but you need to work out what the lifetimes will be.</p>
<p>If your main function looks like this:</p>
<pre><code class="language-rust ignore">let test_str = "Hello, world!";
let split_at = "l";
let mut collection = Vec::new();

split(test_str, split_at, &amp;mut collection);

dbg!(collection);</code></pre>
<p>Then your output should look something like this:</p>
<pre><code class="language-text">[src\main.rs:17:5] collection = [
    "He",
    "",
    "o, wor",
    "d!",
]
</code></pre>
<p>This isn‚Äôt an easy task, and will require thinking about the lifetimes carefully.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/control-flow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/control-flow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
